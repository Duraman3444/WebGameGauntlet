---
alwaysApply: true
---
# .cursorrules

## Project Overview
- This is a **Fruit Runners** 2D platformer game built with Vite, React, and Phaser 3
- Features comprehensive asset loading system with fallback placeholders
- Includes extensive debugging tools and logging for development
- Supports real-time multiplayer with Socket.io
- Uses modern web technologies with TypeScript for type safety

## Development Standards
- Use TypeScript for all files with proper type annotations
- Use Tailwind CSS for UI styling (menus, HUD, components)
- Use Phaser 3 for game rendering, physics, and animations
- Use Zustand for state management
- Use Socket.io for real-time multiplayer communication
- Use React Query for server state management
- Follow React web development best practices and performance guidelines
- Use functional components with hooks for UI components
- Prefer const assertions and proper typing

## Project Structure
- Keep components in `src/components/` directory
- Keep pages in `src/pages/` directory
- Keep stores in `src/stores/` directory
- Keep API calls in `src/api/` directory
- Keep game-specific code in `src/game/` directory:
  - Game scenes in `src/game/scenes/`
  - Game entities in `src/game/entities/`
  - Game systems in `src/game/systems/`
  - Game configuration in `src/game/config/`
- Keep utilities in `src/utils/` directory
- Use absolute imports with path mapping

## Asset Management
- Assets are organized in `public/assets/` with clear structure:
  - `sprites/players/Main Characters/` for character spritesheets
  - `sprites/items/` for collectibles (Fruits/, Boxes/)
  - `sprites/traps/` for hazards and interactive elements
  - `sprites/terrain/` for level tiles and platforms
  - `sprites/menu/` for UI elements and buttons
  - `levels/` for level-specific assets
- Use `encodeURI()` for paths containing spaces or special characters
- Implement fallback placeholders for missing assets
- Include comprehensive asset loading logs with emoji indicators
- Use AssetVerifier utility for debugging missing assets

## Code Quality
- Follow responsive design principles for UI elements
- Handle accessibility properly with ARIA attributes and semantic HTML
- Use React Router for navigation between game states
- Implement proper loading states and error boundaries
- Optimize for web performance (code splitting, lazy loading)
- Use modern web standards and best practices
- Structure files: exported component, hooks, helpers, types
- Make everything modular - each feature should be self-contained

## Development Workflow
- Create a new branch for every feature, bug fix, or significant change
- Use descriptive branch names (e.g., `feature/asset-loading`, `fix/collision-bug`)
- Keep features isolated and avoid cross-feature dependencies when possible
- Don't overengineer solutions - keep it simple and maintainable
- Use comprehensive logging for debugging (console.log with emojis)
- Test asset loading thoroughly with debug tools

## Game-Specific Guidelines
- Follow modern platformer game mechanics and feel
- Implement proper platformer physics (gravity, jumping, collision detection)
- Support 2-4 players in real-time multiplayer
- Include character selection with 4 unique characters
- Create side-scrolling platformer levels with obstacles, collectibles, and hazards
- Implement comprehensive trap system (spikes, fire, saws, trampolines, falling platforms)
- Add fruit collection and scoring system with proper feedback
- Include proper game states (menu, lobby, playing, game over)
- Ensure smooth 60fps gameplay with optimized physics
- Handle player respawning and checkpoint system
- Implement level progression with Mario 1-1 inspired design
- Add comprehensive debug logging for all game systems
- Ensure network synchronization for multiplayer
- Handle player disconnections gracefully
- Add game timer and level completion mechanics

## Technical Implementation
- Use Phaser 3 Arcade Physics for platformer mechanics
- Implement static bodies for platforms, walls, and boxes for better performance
- Use dynamic bodies for players and collectibles
- Create efficient sprite management and animation system
- Implement proper collision detection with overlap and collision callbacks
- Use Socket.io for real-time player movement and action synchronization
- Implement client-side prediction for smooth gameplay
- Add proper error handling for network issues and asset loading
- Create responsive game canvas that scales properly
- Optimize asset loading with comprehensive fallback system
- Implement proper game loop with fixed timestep
- Add extensive debugging tools and console logging
- Use AssetVerifier for pre-load asset checking

## Debugging and Logging
- Use emoji-based console logging for easy identification:
  - ‚úÖ = Success/loaded
  - ‚ùå = Error/failed
  - ‚ö†Ô∏è = Warning/missing optional
  - üé≠ = Animation system
  - üèóÔ∏è = Level construction
  - üéÆ = Game events
  - üë§ = Player actions
  - üì¶ = Asset loading
- Include detailed error messages with file paths
- Implement comprehensive asset verification before loading
- Add progress tracking for asset loading
- Log all game system initialization and state changes
- Include performance monitoring for frame rate and memory usage

## Performance Optimization
- Use static physics bodies for immovable objects
- Implement proper object pooling for frequently created/destroyed objects
- Optimize sprite rendering with efficient texture management
- Use proper collision groups to reduce unnecessary collision checks
- Implement level-of-detail for distant objects
- Use efficient particle systems for effects
- Optimize network communication with proper event batching
- Implement proper memory management and cleanup

## Asset Loading Best Practices
- Always provide fallback placeholders for missing assets
- Use proper error handling for failed asset loads
- Implement progress tracking and user feedback
- Organize assets in logical directory structure
- Use consistent naming conventions for asset files
- Implement asset verification tools for debugging
- Support both development and production asset paths
- Use efficient loading strategies (preload vs on-demand)

## Testing and Quality Assurance
- Test asset loading with missing files to verify fallbacks work
- Verify all character animations play correctly
- Test collision detection thoroughly across all game objects
- Ensure multiplayer synchronization works properly
- Test responsive design across different screen sizes
- Verify performance maintains 60fps during gameplay
- Test error handling and graceful degradation
- Use debug tools to verify all systems are working correctly

## Timeline Considerations
- Prioritize core functionality over visual polish
- Implement comprehensive debugging early in development
- Use placeholder assets to unblock development
- Focus on solid game mechanics before adding features
- Ensure proper asset loading system before adding more assets
- Test multiplayer functionality thoroughly before deployment
- Keep features modular for easy iteration and debugging